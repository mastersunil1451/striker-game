<!DOCTYPE html>
<html>
<head>
    <title>Striker Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <style>
        /* HTML & body full height */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }
        body {
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* Fullscreen game container */
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #2a2a2a;
        }
        canvas {
            display: block;
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        button {
            padding: 15px 30px;
            margin: 10px;
            font-size: 1.2em;
            background: #4CAF50;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="homeScreen" class="screen">
            <h1>Striker Game</h1>
            <button onclick="startGame()">üéÆ Start Game</button>
            <button onclick="showHowToPlay()">üìñ How to Play</button>
        </div>
        
        <div id="howToScreen" class="screen" style="display: none;">
            <h2>How to Play</h2>
            <p>1. Drag the striker in the opposite direction to aim</p>
            <p>2. Release to shoot</p>
            <p>3. Overlap 50% of your striker with the target</p>
            <p>4. Screen scrolls down after each successful hit</p>
            <button onclick="goHome()">‚Ü©Ô∏è Back</button>
        </div>
        
        <div id="gameOverScreen" class="screen" style="display: none;">
            <h2>Game Over!</h2>
            <p id="finalScore"></p>
            <button onclick="restartGame()">üéØ Restart</button>
            <button onclick="goHome()">‚Ü©Ô∏è Back</button>
        </div>
        
        <div id="score">Score: 0</div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameLoop;
let gameState = 'home';
let score = 0;
let scrollOffset = 0;

// Game objects
const striker = {
    x: 0,
    y: 0,
    radius: 20,
    color: '#ff6b6b',
    velocityX: 0,
    velocityY: 0,
    isDragging: false,
    dragStart: {x: 0, y: 0},
    hasLaunched: false
};

const target = {
    x: 0,
    y: 0,
    size: 80,
    shape: 'circle',
    color: '#4ecdc4'
};

// Resize canvas to full viewport dimensions
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    resetStriker();
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Game controls
function startGame() {
    gameState = 'playing';
    score = 0;
    scrollOffset = 0;
    resetStriker();
    spawnTarget();
    document.getElementById('homeScreen').style.display = 'none';
    gameLoop = requestAnimationFrame(update);
}

function restartGame() {
    gameState = 'playing';
    score = 0;
    scrollOffset = 0;
    resetStriker();
    spawnTarget();
    document.getElementById('gameOverScreen').style.display = 'none';
    gameLoop = requestAnimationFrame(update);
}

function showHowToPlay() {
    document.getElementById('homeScreen').style.display = 'none';
    document.getElementById('howToScreen').style.display = 'flex';
}

function goHome() {
    gameState = 'home';
    document.querySelectorAll('.screen').forEach(screen => screen.style.display = 'none');
    document.getElementById('homeScreen').style.display = 'flex';
    cancelAnimationFrame(gameLoop);
}

// Striker controls
function resetStriker() {
    striker.x = canvas.width / 2;
    striker.y = canvas.height / 2; // Centered vertically
    striker.velocityX = 0;
    striker.velocityY = 0;
    striker.hasLaunched = false;
}

// Target spawning with full screen coverage
function spawnTarget() {
    target.shape = ['circle', 'square'][Math.floor(Math.random() * 2)];
    target.size = Math.random() * 40 + 60;
    target.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
    
    // Random position anywhere on canvas
    target.x = Math.random() * (canvas.width - target.size) + target.size / 2;
    target.y = scrollOffset + Math.random() * (canvas.height - target.size) + target.size / 2;
}

// Physics and collision detection
function checkCollision() {
    const targetRadius = target.size / 2;
    const strikerRadius = striker.radius;
    const dx = striker.x - target.x;
    const dy = striker.y - (target.y - scrollOffset);
    
    switch(target.shape) {
        case 'circle':
            return Math.hypot(dx, dy) < (targetRadius + strikerRadius / 2);
        case 'square':
            return (
                striker.x > target.x - target.size / 2 + strikerRadius / 2 &&
                striker.x < target.x + target.size / 2 - strikerRadius / 2 &&
                striker.y > (target.y - scrollOffset) - target.size / 2 + strikerRadius / 2 &&
                striker.y < (target.y - scrollOffset) + target.size / 2 - strikerRadius / 2
            );
    }
    return false;
}

// Input handling
canvas.addEventListener('mousedown', (e) => handleStart(e));
canvas.addEventListener('touchstart', (e) => handleStart(e.changedTouches[0]));

function handleStart(e) {
    if (gameState !== 'playing' || striker.velocityX !== 0 || striker.velocityY !== 0) return;
    
    const rect = canvas.getBoundingClientRect();
    const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
    const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
    
    if (Math.hypot(mouseX - striker.x, mouseY - striker.y) < striker.radius) {
        striker.isDragging = true;
        striker.dragStart.x = mouseX;
        striker.dragStart.y = mouseY;
    }
}

canvas.addEventListener('mousemove', (e) => handleMove(e));
canvas.addEventListener('touchmove', (e) => handleMove(e.changedTouches[0]));

function handleMove(e) {
    if (!striker.isDragging) return;
    
    const rect = canvas.getBoundingClientRect();
    const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
    const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
    
    striker.x = mouseX;
    striker.y = mouseY;
}

canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('touchend', handleEnd);

function handleEnd() {
    if (!striker.isDragging) return;
    striker.isDragging = false;
    
    const dx = striker.dragStart.x - striker.x;
    const dy = striker.dragStart.y - striker.y;
    const distance = Math.hypot(dx, dy);
    
    if (distance > 30) {
        const angle = Math.atan2(dy, dx);
        const force = Math.min(distance * 0.15, 20);
        striker.velocityX = Math.cos(angle) * force;
        striker.velocityY = Math.sin(angle) * force;
        striker.hasLaunched = true;
    } else {
        resetStriker();
    }
}

// Game loop
function update() {
    if (gameState !== 'playing') return;
    
    // Update physics
    striker.x += striker.velocityX;
    striker.y += striker.velocityY;
    
    // Apply friction
    striker.velocityX *= 0.95;
    striker.velocityY *= 0.95;
    
    // Boundary collision
    if (striker.x - striker.radius < 0) {
        striker.x = striker.radius;
        striker.velocityX *= -0.5;
    }
    if (striker.x + striker.radius > canvas.width) {
        striker.x = canvas.width - striker.radius;
        striker.velocityX *= -0.5;
    }
    if (striker.y - striker.radius < 0) {
        striker.y = striker.radius;
        striker.velocityY *= -0.5;
    }
    if (striker.y + striker.radius > canvas.height) {
        striker.y = canvas.height - striker.radius;
        striker.velocityY *= -0.5;
    }
    
    // Check if stopped
    if (Math.abs(striker.velocityX) < 0.1 && Math.abs(striker.velocityY) < 0.1) {
        striker.velocityX = 0;
        striker.velocityY = 0;
        
        if (striker.hasLaunched) {
            if (checkCollision()) {
                score++;
                scrollOffset += 100; // Scroll down Y-axis
                resetStriker();
                spawnTarget();
            } else {
                gameState = 'gameOver';
                document.getElementById('finalScore').innerText = `Score: ${score}`;
                document.getElementById('gameOverScreen').style.display = 'flex';
                cancelAnimationFrame(gameLoop);
            }
        }
    }
    
    render();
    requestAnimationFrame(update);
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw target
    ctx.fillStyle = target.color;
    ctx.beginPath();
    switch(target.shape) {
        case 'circle':
            ctx.arc(target.x, target.y - scrollOffset, target.size / 2, 0, Math.PI * 2);
            break;
        case 'square':
            ctx.rect(target.x - target.size / 2, target.y - scrollOffset - target.size / 2, target.size, target.size);
            break;
    }
    ctx.fill();
    
    // Draw striker
    ctx.fillStyle = striker.color;
    ctx.beginPath();
    ctx.arc(striker.x, striker.y, striker.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw drag indicator
    if (striker.isDragging) {
        ctx.strokeStyle = 'rgba(255, 100, 100, 0.5)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(striker.dragStart.x, striker.dragStart.y);
        ctx.lineTo(striker.x, striker.y);
        ctx.stroke();
        
        ctx.fillStyle = 'rgba(255, 100, 100, 0.3)';
        ctx.beginPath();
        ctx.arc(striker.dragStart.x, striker.dragStart.y, striker.radius, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Update score
    document.getElementById('score').innerText = `Score: ${score}`;
}

// Initial setup
resetStriker();
</script>
</body>
</html>
